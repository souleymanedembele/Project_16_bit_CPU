\documentclass{article}
\usepackage[table]{xcolor}
\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsfonts, amssymb, amsthm} 
\usepackage{graphicx}
\usepackage{multicol}
% \usepackage{underscore}
\usepackage[margin=1.0in]{geometry} % see geometry.pdf on how to lay out the page. There's lots.
%\usepackage[compact]{titlesec}         % you need this package
%\titlespacing{\section}{0pt}{0pt}{0pt}
\graphicspath{ {./images/} }
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=black,bookmarksopen=true]{hyperref}

\title{\textbf{TCES 330: Lab5 Write Up}}
\author{Souleymane Dembele \\ \\ \textbf{School of Engineering and Technology, UWT} \\  \\ \textbf{Professor}:  Jie Sheng, Ph.D.}
% \date{} % delete this line to display the current date

%%% BEGIN DOCUMENT
\begin{document}

\maketitle

\section*{Summary of Lab5 Experience}
In Lab5, we designed and test counters circuit using differrent approches. We had 3 Parts for Lab5.
In Part1, the 16-bit counter was implemented by instantiating sixteen instances of a T-type flip-flop module.
Part2: Part2 simplified the counter implementation by using the SystemVerilog statement Q <= Q + 1'b1.
In Part3, an LPM (Library of Parameterized Modules) approach was used to implement the 16-bit counter.
\\\\
In Part 1, we implemented a 16-bit counter using a 4-bit synchronous counter as an instance. The 16-bit counter utilized sixteen instances of a T-type flip-flop module. 
The counter incremented on each positive edge of the clock when the Enable signal was asserted, and it could be reset to 0 using the Clear (Reset) signal.
For Part1  we used ModelSim for simulation. We created a testbench named CounterSixteen1\_tb to test the circuit. 
In response to the question 6 in part in Part1, we see that the rtl view Part1rtlview2 shows 16 TFF and they are all connected to each other in a chain using the Q and QN ports of the TFFs.
That is a counter as wee did in 230 as well.
When it comes to the logic elements, we see that the total logic elements used is 50. In addition, we see that the total registers used is 16 and the Fmax is 360.23MHz and the restricted Fmax is 250.0MHz and KEY[0] was the clock name.
\\\\
For Part2, we implemented using case procedure and we used ModelSim for simulation. We created a testbench named CounterSixteen2\_tb to test the circuit. 
In response to the question 6 in Part2, the counter unit uses multiplexer, D-FlipFlop and adder. The multiplexer is used to select the input of the D-FlipFlop. 
The adder is used to add 1 to the input of the D-FlipFlop. The D-FlipFlop is used to store the value of the counter.
When it comes to logic elements, we see that the total logic elements used is 45. In addition, we see that the total registers used is 16 and the Fmax is 386.55MHz and the restricted Fmax is 250.0MHz and KEY[0] was the clock name.
\\\\
Part3 did not involve simulation using ModelSim, and it was mentioned that the incorporation of LPMs in ModelSim simulations was discussed later in class.
In response to the question 6 in Part3, the PLM module also has multiple (16) unit same as the Part1.
When it comes to logic elements, we see that the total logic elements used is 46. In addition, we see that the total registers used is 16 and the Fmax is 386.7MHz and the restricted Fmax is 250.0MHz and KEY[0] was the clock name.
\\\\
In conclusion, we learned how to design and test counters circuit using differrent approches. We had 3 Parts for Lab5. 
In Part1, the 16-bit counter was implemented by instantiating sixteen instances of a T-type flip-flop module.In Part2 simplified the counter,
In Part3, an LPM (Library of Parameterized Modules) approach was used to implement the 16-bit counter. When comes to the frequency of the clock, we see that the frequency restricted of the clock is 250MHz and Fmax for Part2 and 3 are higher than the one of Part1.
For the logic elements, we see that the total logic elements used is 50 for Part1, 45 for Part2 and 46 for Part3, we see that the total registers used is 16 for all the parts.

\end{document}